import frappe

def is_fms_enable():
    """Check if FMS is enabled"""
    return frappe.db.get_value("FMS Settings", "FMS Settings", "enable")

def is_applied_on_doctype(doc):
    """Check if workflow automation is applied on the given doctype"""
    return frappe.db.exists("FMS Settings Doctypes", {
        "parent": "FMS Settings",
        "doctype_": doc.doctype,
        "active": 1
    })

def on_update(doc, method):
    """Handle document updates"""
    if not is_fms_enable() or not is_applied_on_doctype(doc):
        return

    manage_todos_from_child_table(doc)


import frappe
from frappe.utils import get_datetime
from datetime import datetime, timedelta, time

def get_tat(row):
    if not row.expected_start_time or not row.expected_end_time:
        return 0

    expected_start = get_datetime(row.expected_start_time)
    expected_end = get_datetime(row.expected_end_time)

    if expected_start >= expected_end:
        return 0

    # 1. Get employee from allocated_user
    user_id = row.assigned_to
    employee = frappe.db.get_value("Employee", {"user_id": user_id}, ["name", "default_shift"], as_dict=True)
    shift_name = employee.default_shift if employee else None

    # 2. Get shift start, end, and holiday list
    shift_start_time = time(0, 0, 0)           # default: 12:00 AM
    shift_end_time = time(23, 59, 59)          # default: 11:59:59 PM
    holidays = set()

    if shift_name:
        shift = frappe.get_doc("Shift Type", shift_name)
        if shift.start_time:
            shift_start_time = shift.start_time
        if shift.end_time:
            shift_end_time = shift.end_time

        if shift.holiday_list:
            holidays = set(frappe.db.get_all(
                "Holiday",
                filters={"parent": shift.holiday_list},
                pluck="holiday_date"
            ))

    # 3. Iterate day by day, calculating working seconds
    total_seconds = 0
    current_date = expected_start.date()
    end_date = expected_end.date()

    while current_date <= end_date:
        is_holiday = str(current_date) in holidays

        if not is_holiday:
            shift_start_dt = datetime.combine(current_date, shift_start_time)
            shift_end_dt = datetime.combine(current_date, shift_end_time)

            # Adjust times if it's the start or end day
            day_start = max(expected_start, shift_start_dt)
            day_end = min(expected_end, shift_end_dt)

            if day_start < day_end:
                total_seconds += (day_end - day_start).total_seconds()

        current_date += timedelta(days=1)

    return int(total_seconds)



def manage_todos_from_child_table(doc):
    """Main function to manage ToDos based on child table"""
    child_table_name = f"{doc.doctype.lower().replace(' ', '_')}_dt_fms_task_assignment"

    if child_table_name not in [df.fieldname for df in doc.meta.get_table_fields()]:
        return

    current_rows = doc.get(child_table_name) or []
    existing_todos = get_existing_todos(doc)
    processed_todos = set()

    # Process current rows
    for row in current_rows:
        if not (row.get('subject') and row.get('assigned_to')):
            continue

        todo_name = f"{doc.doctype}-{doc.name}-{row.name}"
        todo_data = {
            "doctype": "ToDo",
            "custom_row_reference": row.name,  # Critical: Store row reference
            "allocated_to": row.assigned_to,
            "description": format_description(row),
            "reference_type": doc.doctype,
            "reference_name": doc.name,
            "priority": "Medium",
            "status": row.get("status", "Open"),
            "assigned_by": frappe.session.user,
            "custom_tat_start_time": row.get("expected_start_time"),
            "custom_expected_end_time": row.get("expected_end_time"),
            "custom_tat": get_tat(row),  # Calculate TAT based on doc
        }

        if todo_name in existing_todos:
            update_existing_todo(todo_name, todo_data)
        else:
            create_new_todo(todo_name, todo_data)

        processed_todos.add(todo_name)

    # Cancel todos for removed rows
    cancel_removed_todos(existing_todos, processed_todos)

def format_description(row):
    """Format the ToDo description from row data"""
    subject = row.get('subject', '')
    description = row.get('description', '')
    return f"{subject}\n{description}" if subject and description else description or subject

def get_existing_todos(doc):
    """Get all existing ToDos for this document generated by the child table (custom_row_reference not null)"""
    todos = frappe.get_all("ToDo",
        filters={
            "reference_type": doc.doctype,
            "reference_name": doc.name,
            "custom_row_reference": ["is", "set"],  # Only fetch ToDos linked to child rows
        },
        fields=["name", "custom_row_reference", "status"]
    )

    # Return as dictionary with name as key and a dict of custom_row_reference and status as value
    return {
        todo.name: {
            "custom_row_reference": todo.custom_row_reference,
            "status": todo.status
        } for todo in todos
    }




def create_new_todo(todo_name, todo_data):
    """Create a new ToDo with proper naming"""
    try:
        todo = frappe.get_doc(todo_data)
        todo.insert(ignore_permissions=True)

        if todo.name != todo_name:
            frappe.rename_doc("ToDo", todo.name, todo_name, force=True)
        # frappe.msgprint(f"Created ToDo: {todo_name}")
    except Exception as e:
        frappe.log_error(f"Failed to create ToDo {todo_name}: {str(e)}")

def update_existing_todo(todo_name, todo_data):
    """Update an existing ToDo only if data has changed"""
    try:
        todo = frappe.get_doc("ToDo", todo_name)
        is_changed = False

        for field, new_value in todo_data.items():
            # Get current value of the field
            current_value = todo.get(field)
            if current_value != new_value:
                todo.set(field, new_value)
                is_changed = True

        if is_changed:
            todo.save(ignore_permissions=True)
            print(f"ToDo {todo_name} updated.")
        else:
            print(f"ToDo {todo_name} not changed. Skipping update.")

    except Exception as e:
        frappe.log_error(f"Failed to update ToDo {todo_name}: {str(e)}")



def cancel_removed_todos(existing_todos, processed_todos):
    """Cancel todos that are no longer in child table"""
    for todo_name, ref_status in existing_todos.items():
        # if status == "Cancelled" continue
        if ref_status['status'] == "Cancelled":
            continue
        if todo_name not in processed_todos:
            try:
                todo = frappe.get_doc("ToDo", todo_name)
                todo.status = "Cancelled"
                todo.save(ignore_permissions=True)
                # frappe.msgprint(f"Cancelled ToDo for removed task: {todo_name}")
            except Exception as e:
                frappe.log_error(f"Failed to cancel ToDo {todo_name}: {str(e)}")
